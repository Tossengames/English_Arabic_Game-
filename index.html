<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sky Road Stacker</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: sans-serif; touch-action: none; }
        canvas { display: block; }
        #menu {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9); padding: 20px; border-radius: 10px;
            display: flex; flex-direction: column; gap: 10px; width: 300px;
        }
        h2 { text-align: center; margin-top: 0; }
        label { font-size: 12px; font-weight: bold; }
        input { margin-bottom: 5px; width: 100%; }
        button { padding: 10px; background: #2ecc71; border: none; color: white; cursor: pointer; border-radius: 5px; font-weight: bold; }
        #scoreUI { position: absolute; top: 10px; left: 10px; font-size: 24px; color: white; text-shadow: 2px 2px 4px #000; pointer-events: none; }
    </style>
</head>
<body>

    <div id="scoreUI" style="display:none;">Score: 0</div>

    <div id="menu">
        <h2>Sky Road Settings</h2>
        <label>Road Block Width (px):</label>
        <input type="number" id="roadWidth" value="100">
        <label>Road Block Height (px):</label>
        <input type="number" id="roadHeight" value="150">
        <label>Initial Car Speed:</label>
        <input type="number" id="carSpeed" value="2">
        <label>Min Block Speed:</label>
        <input type="number" id="minBSpeed" value="3">
        <label>Max Block Speed:</label>
        <input type="number" id="maxBSpeed" value="7">
        <button onclick="startGame()">START GAME</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const menu = document.getElementById('menu');
const scoreUI = document.getElementById('scoreUI');

let gameActive = false;
let score = 0;
let difficultyMultiplier = 1;

// Configurable Settings
let config = {};

// Game Objects
let car = { x: 0, y: 0, w: 40, h: 60, speed: 0 };
let blocks = [];
let incomingBlock = null;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function startGame() {
    config = {
        roadW: parseInt(document.getElementById('roadWidth').value),
        roadH: parseInt(document.getElementById('roadHeight').value),
        carS: parseFloat(document.getElementById('carSpeed').value),
        minBS: parseFloat(document.getElementById('minBSpeed').value),
        maxBS: parseFloat(document.getElementById('maxBSpeed').value)
    };

    menu.style.display = 'none';
    scoreUI.style.display = 'block';
    
    // Initial Setup
    score = 0;
    difficultyMultiplier = 1;
    blocks = [];
    
    // Create initial 3 blocks (centered)
    const startX = canvas.width / 2 - config.roadW / 2;
    for(let i = 0; i < 3; i++) {
        blocks.push({
            x: startX,
            y: canvas.height - (i + 1) * config.roadH,
            w: config.roadW,
            h: config.roadH,
            active: true
        });
    }

    car.w = config.roadW * 0.4;
    car.h = car.w * 1.5;
    car.x = canvas.width / 2 - car.w / 2;
    car.y = blocks[0].y + (config.roadH/2);
    car.speed = config.carS;

    incomingBlock = null;
    gameActive = true;
    animate();
}

function spawnIncomingBlock() {
    if (incomingBlock) return;

    const side = Math.random() > 0.5 ? 1 : -1; // 1 = right, -1 = left
    const width = config.roadW * (1 + Math.random() * 2); // Random size up to 3x car
    const speed = (config.minBS + Math.random() * (config.maxBS - config.minBS)) * difficultyMultiplier;
    
    const lastBlock = blocks[blocks.length - 1];
    
    incomingBlock = {
        x: side === 1 ? canvas.width : -width,
        y: lastBlock.y - config.roadH,
        w: width,
        h: config.roadH,
        vx: side === 1 ? -speed : speed,
        moving: true
    };
}

// Input handling
window.addEventListener('mousedown', handleAction);
window.addEventListener('touchstart', (e) => { e.preventDefault(); handleAction(); });

function handleAction() {
    if (!gameActive) return;
    if (incomingBlock && incomingBlock.moving) {
        incomingBlock.moving = false;
        incomingBlock.active = true;
        blocks.push(incomingBlock);
        incomingBlock = null;
        score++;
        difficultyMultiplier += 0.05; // Make it harder
    }
}

function update() {
    if (!gameActive) return;

    // Move Car
    car.y -= car.speed * difficultyMultiplier;

    // Check if car passed middle of current block to spawn next
    // We look at the block the car is currently "on"
    let currentBlockIndex = blocks.findIndex(b => car.y + car.h > b.y && car.y < b.y + b.h);
    if (currentBlockIndex !== -1 && !incomingBlock && blocks.length < currentBlockIndex + 4) {
        spawnIncomingBlock();
    }

    // Move incoming block
    if (incomingBlock && incomingBlock.moving) {
        incomingBlock.x += incomingBlock.vx;
        // Bounce off edges so it doesn't disappear
        if (incomingBlock.x + incomingBlock.w > canvas.width || incomingBlock.x < 0) {
            incomingBlock.vx *= -1;
        }
    }

    // Collision / Fall Logic
    let onRoad = false;
    blocks.forEach(b => {
        if (car.x + car.w/2 > b.x && car.x + car.w/2 < b.x + b.w &&
            car.y + car.h > b.y && car.y < b.y + b.h) {
            onRoad = true;
        }
    });

    if (!onRoad) {
        gameActive = false;
        alert("Game Over! Score: " + score);
        location.reload();
    }

    // Camera follow (keep car roughly in lower-middle)
    const targetScroll = car.y - canvas.height * 0.6;
    ctx.setTransform(1, 0, 0, 1, 0, -targetScroll);
}

function draw() {
    if (!gameActive) return;
    ctx.clearRect(-1000, car.y - 2000, canvas.width + 2000, 4000);

    // Draw Blocks
    blocks.forEach(b => {
        ctx.fillStyle = "#555"; // Road color
        ctx.fillRect(b.x, b.y, b.w, b.h);
        ctx.strokeStyle = "#fff";
        ctx.strokeRect(b.x, b.y, b.w, b.h);
    });

    // Draw Incoming Block
    if (incomingBlock) {
        ctx.fillStyle = "#e74c3c"; // Moving block color
        ctx.fillRect(incomingBlock.x, incomingBlock.y, incomingBlock.w, incomingBlock.h);
    }

    // Draw Car
    ctx.fillStyle = "#f1c40f"; // Car color
    ctx.fillRect(car.x, car.y, car.w, car.h);

    scoreUI.innerText = "Score: " + score;
}

function animate() {
    update();
    draw();
    if (gameActive) requestAnimationFrame(animate);
}
</script>
</body>
</html>
