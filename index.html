<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sky Road 3D Stacker</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1e272e; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; background: linear-gradient(#1e90ff, #87CEEB); }
        #menu {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95); padding: 25px; border-radius: 15px;
            display: flex; flex-direction: column; gap: 8px; width: 280px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        h2 { text-align: center; margin: 0 0 10px 0; color: #2f3542; }
        label { font-size: 11px; font-weight: bold; color: #57606f; text-transform: uppercase; }
        input { padding: 8px; border: 1px solid #ccc; border-radius: 5px; }
        button { margin-top: 10px; padding: 12px; background: #ff4757; border: none; color: white; cursor: pointer; border-radius: 5px; font-weight: bold; font-size: 16px; }
        #scoreUI { position: absolute; top: 20px; width: 100%; text-align: center; font-size: 40px; color: white; font-weight: bold; text-shadow: 2px 2px 10px rgba(0,0,0,0.5); pointer-events: none; }
    </style>
</head>
<body>

    <div id="scoreUI" style="display:none;">0</div>

    <div id="menu">
        <h2>Settings</h2>
        <label>Road Width</label>
        <input type="number" id="roadWidth" value="200">
        <label>Car Speed</label>
        <input type="number" id="carSpeed" value="5">
        <label>Min Block Speed</label>
        <input type="number" id="minBSpeed" value="4">
        <label>Max Block Speed</label>
        <input type="number" id="maxBSpeed" value="8">
        <button onclick="startGame()">RACE START</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const menu = document.getElementById('menu');
const scoreUI = document.getElementById('scoreUI');

let gameActive = false;
let score = 0;
let distanceTraveled = 0;
let difficulty = 1;

let config = {};
let blocks = [];
let incomingBlock = null;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function startGame() {
    config = {
        roadW: parseInt(document.getElementById('roadWidth').value),
        carS: parseFloat(document.getElementById('carSpeed').value),
        minBS: parseFloat(document.getElementById('minBSpeed').value),
        maxBS: parseFloat(document.getElementById('maxBSpeed').value)
    };

    menu.style.display = 'none';
    scoreUI.style.display = 'block';
    
    score = 0;
    distanceTraveled = 0;
    difficulty = 1;
    blocks = [];

    // Horizon line is at 40% of screen height
    const horizon = canvas.height * 0.4;

    // Initial 3 blocks (z represents distance from camera)
    for(let i = 0; i < 4; i++) {
        blocks.push({
            x: canvas.width / 2 - config.roadW / 2,
            z: i * 200, // Distance
            w: config.roadW,
            active: true
        });
    }

    incomingBlock = null;
    gameActive = true;
    animate();
}

function spawnIncomingBlock() {
    if (incomingBlock) return;

    const lastBlock = blocks[blocks.length - 1];
    const side = Math.random() > 0.5 ? 1 : -1;
    const width = config.roadW * (0.8 + Math.random() * 1.5);
    const speed = (config.minBS + Math.random() * (config.maxBS - config.minBS)) * difficulty;
    
    incomingBlock = {
        x: side === 1 ? canvas.width + width : -width,
        z: lastBlock.z + 200,
        w: width,
        vx: side === 1 ? -speed : speed,
        moving: true
    };
}

function handleAction() {
    if (!gameActive) return;
    if (incomingBlock && incomingBlock.moving) {
        incomingBlock.moving = false;
        blocks.push(incomingBlock);
        incomingBlock = null;
        score++;
        difficulty += 0.08;
    }
}

window.addEventListener('mousedown', handleAction);
window.addEventListener('touchstart', (e) => { e.preventDefault(); handleAction(); });

function update() {
    if (!gameActive) return;

    const speed = config.carS * difficulty;
    distanceTraveled += speed;

    // Move blocks toward camera
    blocks.forEach(b => b.z -= speed);
    if (incomingBlock) incomingBlock.z -= speed;

    // Remove old blocks
    if (blocks[0] && blocks[0].z < -200) {
        blocks.shift();
    }

    // Spawn new block logic
    if (!incomingBlock && blocks.length < 5) {
        spawnIncomingBlock();
    }

    // Move incoming block horizontally
    if (incomingBlock && incomingBlock.moving) {
        incomingBlock.x += incomingBlock.vx;
        // Bounce within screen bounds
        if (incomingBlock.x > canvas.width || incomingBlock.x + incomingBlock.w < 0) {
            incomingBlock.vx *= -1;
        }
    }

    // Check if the block the car is currently "on" exists
    // The car is effectively at Z = 50
    let currentBlock = blocks.find(b => b.z < 100 && b.z > -100);
    
    if (currentBlock) {
        const carCenterX = canvas.width / 2;
        if (carCenterX < currentBlock.x || carCenterX > currentBlock.x + currentBlock.w) {
            gameOver();
        }
    } else if (blocks.length > 0 && blocks[0].z < 0) {
        // If we passed a block and there is no block under us
        gameOver();
    }
}

function gameOver() {
    gameActive = false;
    alert("CRASHED! Score: " + score);
    location.reload();
}

function project(x, z, w) {
    const horizon = canvas.height * 0.4;
    const perspective = 400; 
    const scale = perspective / (perspective + z);
    
    return {
        px: (x - canvas.width / 2) * scale + canvas.width / 2,
        py: horizon + (canvas.height - horizon) * (1 - scale),
        pw: w * scale,
        ph: 50 * scale // Arbitrary height for block thickness
    };
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw blocks from furthest to nearest
    const allBlocks = [...blocks];
    if (incomingBlock) allBlocks.push(incomingBlock);
    
    allBlocks.sort((a, b) => b.z - a.z).forEach(b => {
        if (b.z < 0 && b !== incomingBlock) return;
        
        const p = project(b.x, b.z, b.w);
        
        // Draw Road Block
        ctx.fillStyle = b.moving ? "#ff4757" : "#57606f";
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        ctx.rect(p.px, p.py, p.pw, p.ph * 2);
        ctx.fill();
        ctx.stroke();
    });

    // Draw Car (Static position in 3D space, always at bottom)
    const carWidth = 60;
    const carHeight = 40;
    ctx.fillStyle = "#f1c40f";
    ctx.fillRect(canvas.width / 2 - carWidth / 2, canvas.height - 120, carWidth, carHeight);
    // Windshield
    ctx.fillStyle = "#333";
    ctx.fillRect(canvas.width / 2 - carWidth / 2 + 10, canvas.height - 110, carWidth - 20, 10);

    scoreUI.innerText = score;
}

function animate() {
    update();
    draw();
    if (gameActive) requestAnimationFrame(animate);
}
</script>
</body>
</html>
